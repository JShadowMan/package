Go - Web
--------

Go的`net/http`包提供了基础的路由函数组合与丰富的功能函数。根据经验，如果一个系统只要路由带有参数，并且这个项目的API数量超过10个，就尽量不要使用`net/http`了。


### 请求路由

在Web框架中，路由器是必备的组件。在Go圈子里路由器也经常被称为HTTP多路复用器（Mux, Multiplexer）。

目前开源社区中的Web框架大多使用`httprouter`（现在应该是`mux`比较热门），或是基于httprouter的变种对路由进行支持。

#### httprouter

httprouter中使用的是显式匹配，所以在设计路由时需要规避一些会导致路由冲突的情况。还有一点需要注意，因为httprouter考虑到字典树的深度，在初始化时会对参数的数量进行限制（路由中的参数数目不能超过255，否则会导致httprouter无法识别后续的参数）。

除了正常情况下的路由支持，httprouter也支持对一些特殊情况进行注册回调函数（如出现404错误时，或者内部出现panic时）。

#### 路由实现的原理

httprouter与众多衍生路由库使用的数据库结构被称为压缩动态检索树。所谓“压缩”指的是一个节点中不只存储一个字母，而是存储一整路径。使用压缩检索树可以减少树的层数，同时因为每个节点的数据存储也要比普通的检索树要多，程序的局部性较好（加载一个节点就可以进行多个字符串的比较），从而对CPU缓存友好。

#### 压缩检索树的创建过程

1. 一般情况下，每种Http方法都对应一颗独立的压缩检索树，这些树之间不共享数据。
2. 将注册的路由根据每段路径的类型构造成节点插入到树中。
3. 处理在插入节点过程中可能会出现树的分裂情况（/a/b/c /a/c/d）
4. 处理在插入节点过程中出现的冲突问题（/a/:id/name /a/:name/age）


### 中间件

使用中间件可以将业务代码和非业务代码功能解耦。对于大多数的场景来说，非业务的需求都是在Http请求处理前做一些事情，并且在响应完成之后做一些事情。

中间件要做的事情就是通过一个或多个函数对handler进行包装，返回一个包括了各个中间件逻辑的函数链。

常见的中间件有：
 * `compress`：对Http响应进行压缩，可代理交给nginx来做。
 * `heartbeat`：内置一些路由（如`/ping, /heartcheck`），用于给其他监听服务做探活。
 * `logger`：打印请求日志，如请求时间、请求路由、处理结果。
 * `profile`：内置pprof的一些路由，用于业务上的性能分析。
 * `requestip`：为请求生成唯一的请求Id，可用于分布式链路分析，也可以在所有请求处理中串连所有逻辑日志。
 * `timeout`：为本次请求设置超时时间。
 * `ratelimit`：通过定长的Channel，对接口进行限流保护。


### 请求校验

请求校验是一个与语言无关的场景，对于简单的情况下，我们可以使用卫语句（Guard Clauses）来避免出现深层次的判断嵌套。

从设计角度将，对于每个请求都会声明一个结构体，验证工作也可以通过在结构体中引入标签来完成。
```go
package user

type CreateUserDTO struct {
	Username string `validate:"min=4,max=5"`
}
```

通常在Web环境下，反射一般不会成为程序的性能瓶颈。可以通过pprof中获得更精确的判断，如果大量的使用反射的确是性能瓶颈，也可以考虑使用Go内置的`Parser`对源代码进行扫描，然后根据结构体的定义生成校验代码。

__通过`go generate ./...`来调用解析器为每个请求生成类似于`XXX.Validate()`方法，位于文件`xxx.validate.go`中。__


### 数据库相关

Go官方提供了`database/sql`包来使用户进行和数据库打交道的工作，实际上`database/sql`库知识提供了一套操作数据库的接口和规范（如抽象好的SQL预处理、连接池管理、数据绑定、事务、错误处理等）。如果需要和具体的数据库交互，还需要引入对应数据库的驱动。

__如果需要链接官方`database/sql`库更加详细的用法，可以参考Go语言相关文档（http://go-database-sql.org）__

在开发过程中经常会使用ORM（Object Relational Mapping，对象关系映射）来提高生产效率。ORM实际做的是从数据库数据到程序类或结构体这样的映射。

因为ORM屏蔽了数据库层的实际操作，可能会意外造成无端的读放大（互联网系统的忌讳之一）。这就是ORM想从设计上隐藏过多的细节而付出的代价（背后的运行完全失控）。

还有一种平衡性比ORM做的更好的模式（SQL Builder），这个模式不像ORM屏蔽了过多的细节，从开发角度上看，对SQL Builder进行简单封装之后也可以非常高效的进行开发。

__如果做得系统是高并发的OLTP在线系统，想在人员充足，分工明确的前提下最大程序控制系统的分析，那使用SQL Builder就不合适了。__

无论ORM还是SQL Builder都存在一个致命的缺点，那就是没办法在系统上线前进行SQL审查。所以现如今，大型的互联网公司核心线上服务都会在代码中直接把SQL放在显眼的位置供DBA评审。


### 服务流量限制

计算机程序可以依据瓶颈分为磁盘IO瓶颈型、CPU计算瓶颈型和网络带宽瓶颈型。分布式场景下有时候外部系统也会导致自身瓶颈。如今操作系统大多实现了IO复用之后，如果程序主要是和网络打交道，那么瓶颈一定在用户程序而不在操作系统内核。

__无论哪种类型的服务，在资源使用到极限时都会导致请求堆积、超时、系统挂起，最终伤害到终端用户的体验。__ 所以不管服务的瓶颈在哪，一定都是要做流量控制的。

常见的流量限制手段有很多，最常见的有漏桶和令牌桶两种。
 * 漏桶：每隔一定时间桶会漏出一个令牌，拿到令牌的程序可以执行，否则只能等待或者放弃。
 * 令牌桶：令牌桶则是主动从桶中拿令牌，桶有一定的容量。所以该方法支持短暂时间的超并发请求。

实际中令牌桶的使用较为广泛，开源界的限流器大多都是基于令牌桶思想开发的（可以参考`github.com/juju/ratelimit`库实现）。

令牌桶的模型是对全局变量的加减法实现的。在Go中可选的实现方法可以通过原子操作、带缓冲的通道来实现。

虽然程序的性能指标很重要，但对用户提供服务时还需要考虑服务整体的QOS（Quality Of Service，服务质量）。服务质量顾名思义，包括可用性、吞吐量、延时、延时变化和丢失等指标。

所以在大公司的Web服务器性能指标中，除了一般的平均响应延时之外，还会考虑响应时间的95分位、99分位等。


### 常见大型Web项目的分层

流行的Web框架一般都支持MVC模式。在MVC模式下，将程序分为3层：
 * `Controller`：负责转发请求，对请求进行处理
 * `View`：负责数据的图形化呈现
 * `Model`：实现程序相应的功能，数据库底层相关的管理和设计等。

随着技术的发展，现在一般都是前后端分离的项目。而在软件愈加复杂的如今，`MVC`模型已经不满足于解耦和复用了，所以有了现如今比较流行的纯后端API服务采用的模型：
 * `Controller`：负责转发请求，对请求进行处理（参数校验等）
 * `Logic/Service`：逻辑服务层，一般是业务逻辑的入口，从这里开始所有的参数都是正确的
 * `DAO/Repository`：主要负责和数据、存储打交道，将下层的简单函数进行封装以接口形式暴露给服务层使用。负责数据的持久化工作。
 * `Model`：数据模型的抽象工作，提供简单基础的方法。

一般在Web项目中，可能请求并不只是Http，也有可能是gRPC或者Thrift，这时候就需要在Controller层之前再有一个协议层，负责各种交互协议的细节。


### 接口和表驱动开发

我们外部依赖总是因为各种不可抗力因素而不断的做升级，而没办法做到完整的向前兼容。通过拆解和异步化虽然解决了一部分问题，但并不能解决所有问题。随着业务发展，单一职责的模块也会变得越来越复杂。

#### 抽象封装

最简单的封装方式是将相似的行为放在一起，然后打包成一个一个的函数。在阅读业务流程代码时，我们只要阅读其函数名就能知晓该流程完成了哪些操作。如果需要修改细节，那么就继续深入到每一个业务步骤去看具体的代码。

#### 引入接口

还可以引入接口来进行抽象。但是在业务发展早期是不适宜引入接口的，早期的业务流程变化很大，过早引入接口会使业务系统增加很多不必要的分层，从而导致每次修改几乎都要全盘否定之前的工作（初期我觉得还是要做一点简单的接口分层，不然后期基本都没啥机会改）。当业务发展到一定阶段，项目中的业务流程基本稳定之后，就可以适当地使用接口来抽象开发了。

面向接口编程的优势在于不用关心具体的实现，如果对应的业务在迭代中发生了改变，那么原本的逻辑对平台方来说也是完全透明的。

#### 接口的优缺点

Go被人称道最多的地方就是其接口设计的正交性，模块之间不需要知晓相互的存在。带来好处一是依赖反转，这是接口再大多数语言中对项目都能产生的影响，而在Go中正交接口的设计场景下甚至可以去除依赖。二是可以由编译器在编译器就能检查到接口未完全实现的异常。

#### 表驱动开发

表驱动开发即是将多个判断转换为通过计算散列来取到对应逻辑的过程。这是一种非常重要的帮我我们简化代码的手段。同时也会带来计算散列的开销，在性能敏感场合下需要多加斟酌。
```go
package main

func generate(v string) {
	switch v {
	case "A": // ...
	case "B": // ...
	case "C": // ...
	}
}

var cbs = map[string]func(){
	"A": func() {},
	"B": func() {},
	"C": func() {},
}

func mapping(v string) {
	cbs[v]()
}
```

### 灰度发布和A/B测试

在大型系统中容错是重要的，能够让系统按百分比、分批次到达终端用户也是很重要的。灰度发布也称金丝雀发布，互联网系统的灰度发布一般通过两种方式实现：
 * **通过分批次部署实现灰度发布**：将一个功能的上线分为N次部署（逐次增加部署的机器/容器数，如1,2,4,8,16...）。一般在旧功能升级迭代时使用较多
 * **通过业务规则进行灰度发布**：一般在比较重要的功能进行较大幅度修改时时使用较多。

#### 通过分批次部署实现灰度发布

通过多次部署上线，来达到只影响到少量用户，结合部署过程中观察程序的错误日志来判断是否有异常发生。

#### 通过业务规则进行灰度发布

常见的业务灰度发布系统有以下规则可选：
 * 按城市发布
 * 按概率发布
 * 按百分比发布
 * 按白名单发布
 * 按业务线发布
 * 按UA发布
 * 按分发渠道发布

**注意：** 在使用按概率发布时，选择使用的哈希算法时不仅要注意性能上的问题，还需要注意哈希之后的值是否分布均匀（一般哈希算法使用较多的是MurmurHash，与其他常见算法相比有3倍以上的性能提升）。
