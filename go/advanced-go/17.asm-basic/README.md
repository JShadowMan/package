Go汇编 - 基础知识
---------------


### 计算机架构

当前流行的计算机基本采用的是冯·诺依曼计算机体系结构（还有哈佛体系结构）。冯·诺依曼结构也被称为普林斯顿结构，采用的是一种将程序指令和数据储存在一起的存储结构。

#### X86-64体系结构

X86-64是AMD公司设计的X86架构的64位扩展，向后兼容16位及32位的X86架构。X86-64目前正式名称为AMD64。
```text
+---------+---------+
| SEGMENT | ADDRESS |
+---------+---------+
| STACK   |   HIGH  |   用于管理每个函数调用时相关的数据
| ...     |    ↓    |
| UNUSED  |    .    |
| ...     |    .    |   
| HEAP    |    .    |   用于管理动态的数据
| DATA    |    .    |   存放全局数据
| RODATA  |    ↑    |   对应只读的数据段
| TEXT    |   LOW   |   一般对应代码段，用于存储要执行的指令数据
+---------+---------+
```

#### Go汇编中的伪寄存器

Go汇编为了简化汇编代码的编写，引入了`PC, FP, SP, SB`这4个伪寄存器。
 * `PC(Program counter)`：伪寄存器`PC`其实就是`IP`指令寄存器的别名
 * `FP(Frame pointer)`：表示函数的帧指针，一般用来返回函数的参数和返回值
 * `SP(Stack pointer)`：表示当前函数栈帧的底部（不包括参数和返回值部分），一般用于定位局部变量
    * 真`SP`寄存器：对应的是栈的底部，一般用于定位调用其他函数的参数和返回值（`(SP)`，`+8(SP)`）
    * 伪`SP`寄存器：一般需要一个标识符和偏移量作为前置（`·Name(SP)`，`·Name+9(SP)`）
 * `SB(Static base pointer)`：表示全局符号位置

#### X86-64指令集

汇编语言在不同的CPU类型、不同的操作系统、不同的汇编工具链下是不可移植的。这种不可移植性正是其普及的极大障碍。

`MOV`指令可以用于将字面值转义到寄存器、将字面值转义到内存、寄存器之间的数据传输、寄存器与内存之间的数据传输（`MOV`指令的内存操作数只能有一个，可以通过临时寄存器达到类似目的）。

`MOV`指令有不同的宽度，分别为`MOVB (byte=1)`，`MOVW (word=2)`，`MOVL (long=4)`，`MOVQ (quad=4)`

基础的算术指令有`ADD`，`SUB`，`MUL`，`DIV`最终结果将存入目标寄存器。基础的逻辑运算指令有`AND`，`OR`，`NOT`等几个指令。控制指令有`CMP`，`JMP-if-x`，`JMP`，`CALL`，`RET`等指令（无条件和有条件的跳转是实现分支和循环控制流的基础指令）。

`LEA`指令用于取地址，并将其存入寄存器。`PUSH`和`POP`用于入栈和出栈指令。

__Go汇编语言可能并没有支持全部的CPU指令，如果遇到没有支持的CPU指令，可以通过Go汇编提供的`BYTE`命令将真实的CPU指令对应的机器码填充到对应的位置。__
