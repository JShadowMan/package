Go汇编 - 函数
-----------

函数标识符通过`TEXT`汇编指令定义，表示该行开始的指令是定义在text内存段。函数定义语法为
```text
TEXT symbol(SB), [flags,] $framesize[-argsize]
```
函数定义由以下5部分组成：
 * `TEXT`：用于定义函数符号，后面跟着的`(SB)`表示函数名符号相对伪寄存器`SB`的偏移量。
 * `symbol`：表示函数的符号，与`(SB)`结合在一起就是一个绝对地址。
 * `flags`：标志部分用于指示函数的一些特殊行为，例如常见的`NOSPLIT, WRAPPER, NEEDCTXT`等。
 * `framesize`：表示函数的**局部变量**需要多大栈空间，包括调用其他函数时准备调用参数的隐式栈空间。
 * `argsize`：表示函数参数的大小，一般可以省略，Go编译器可以从函数声明中推导出参数大小。

__在Go汇编中，函数也是没有类型的。只要函数的名字和参数大小一致就可以认为是相同的函数了。而且在Go汇编中，输入参数和返回值参数没有任何区别（都是通过`FP`寄存器定位）。__


### 函数参数和返回值

在Go汇编中引用参数和返回值需要使用到`FP`这个伪寄存器（表示函数当前帧的开始地址，也就是第一个参数的位置）。

__为了编写易于维护的汇编代码，Go汇编要求，不同职能以`+0(FP), +8(FP)`的方式访问参数和返回值。必须加上一个临时标识符前缀组合之后才能引用。__
```text
// func Example(a, b int) (r0, r1 int)
a+0(FP)
b+8(FP)
r0+16(FP)
r1+24(FP)
```


### 参数和返回值的内存布局

**函数参数和返回值的大小以及对其问题与结构体的大小及成员的对其问题是一致的。** 函数的第一个参数和第一个返回值会分别进行一次地址对齐（第一个返回值地址需要重新对其机器字大小的倍数）。

### 函数中的局部变量

从Go汇编角度看，局部变量时指函数运行时在当前函数栈帧所对应的内存内的变量。**函数栈帧主要由函数参数和返回值、局部变量和其他被调用函数的参数和返回值空间组成**。

为了便于访问局部寄存器，Go语言引入了伪寄存器`SP`，对应当前栈帧的底部。由于函数的调用栈是从高地址向低地址增长的，所以此时伪寄存器`SP`对应的栈帧的底部就为高地址。当前栈帧的顶部对应真寄存器`SP`为低地址。

真寄存器一般用于定位调用其他函数的参数和返回值，因为位于低地址，所以定位变量一般是用正偏移量。而伪寄存器位于高地址，所以定位变量一般是用负偏移量。

__局部变量的布局没有顺序要求，可以根据自己的习惯来组织变量的布局。__

### 调用其他函数

常见的Go汇编实现的函数一般都是叶子函数，也就是被其他函数调用的函数。但是我们也可以做到调用其他函数。

汇编函数的参数是由调用方提供，具体流程如下：
 * 调用方在栈上设置好空间（返回值）和数据（参数）后调用函数
 * 被调用方在返回前将返回值写到指定的位置，然后通过`RET`指令返回调用方
 * 调用方再从返回值对应的栈内存取出结果

Go语言函数的调用参数和返回值都是通过栈传输的，这样做的优点是函数调用栈比较清晰，缺点是函数调用有一定的性能损耗（Go编译器通过函数内联来缓解这个问题的影响）

### 宏函数

宏函数不是由Go汇编定义的，而是Go汇编引入的预处理器自带的特性。
```text
#define __SWAP(a, b, x) MOVQ x, t; MOVQ b, a; MOVQ t, b
```

预处理器可以通过条件编译针对不同的平台定义宏的实现，这样就可以简化平台带来的差异。
