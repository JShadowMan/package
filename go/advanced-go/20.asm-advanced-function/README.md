Go汇编 - 再论函数
---------------

之前讨论的函数主要是叶子函数，其最大的特点是不会调用其他函数，也就是栈的大小是可以预期的。叶子函数基本可以忽略栈溢出的问题。


### 函数调用规范

在Go汇编语言中`CALL`指令用于调用函数，`RET`指令用于从调用函数返回。但是`CALL`指令和`RET`指令不会处理函数调用时输入参数和返回值的问题。
 * `CALL`指令所做的事情类似于`PUSH IP; JMP ·func(SB)`
 * `RET`指令类似于`POP IP`指令，实现函数返回

Go语言函数的参数和返回值完全通过栈传递。以下为从高到低栈的布局图
```text
hi
|   -   ret1    - arg0+24(FP)
|   -   ret0    - arg0+16(FP)
|   -   arg1    - arg0+8(FP)
|   -   arg0    - arg0+0(FP)
---------------------
|   =   CALLER_IP
---------------------
|    CALLER BP
--------------------- (Pseudo-SP)   ---
|   -   loc2    - loc2-8(SP)          |
|   -   loc1    - loc1-16(SP)         |
|   -   loc0    - loc0-24(SP)         |
---------------------                 | FrameSize
|   -   ret_B   - +24(SP)             |
|   -   ret_A   - +16(SP)             |
|   -   arg_B   - +8(SP)              |
|   -   arg_A   - +0(SP)              |
--------------------- (REAL SP)     ---
|    RETURN_IP
---------------------
|
lo
```
执行过程大概为：
 * 调用函数前准备的输入参数和返回值空间
 * `CALL`指令推入栈中的返回地址（`PUSH IP`）
 * 进入被调用函数之后，汇编器自动插入的`BP`寄存器相关的指令
 * 再下面就是局部变量的空间
 * 包含调用其他函数所需要准备的空间
 * 当前函数的返回地址


### 高级汇编语言

Go汇编代码和最终证实执行的代码并不完全等价，可以通过分析编译之后的Go汇编代码和原始汇编代码的区别。
 * 对于带有`NOSPLIT`的函数，将会多分配8字节的空间，用于保存`BP`寄存器。
 * 对于不带`NOSPLIT`的函数，将会插入栈空间检测和栈扩容代码。
    * `MOVQ (TLS), CX`指令用于加载g结构体指针（g结构体位于runtime/runtime2.go）
    * g结构体指针中的`stackguard0`成员是出现爆栈前的警戒线。


### `PCDATA`和`FUNCDATA`

`PCDATA`也叫地址表格，用于在运行时根据`IP(PC)`寄存器的值查询到指令当前对应的函数和位置信息。在汇编中的`PCDATA`用于生成相应的地址表格。

`FUNCDATA`也叫函数信息表格，用于记录函数的参数、局部变量的指针信息。通过`FUNCDATA`，Go语言的辣鸡回收期可以跟踪全部指针的生命周期，同时根据指针指向的地址是否在被移动的栈范围来确定是否要进行指针移动。

`PCDATA`和`FUNCDATA`的数据一般是由编译器自动生成。在函数对应的`CALL`指令处，编译器可以辅助生成`PCDATA`，但是编译器无法生成函数局部变量的表格，因此在汇编函数的局部变量中谨慎使用指针类型。

### 方法函数

方法函数与全局变量非常相似，区别在于第一个参数是隐式接收。对于非指针接收的方法函数，函数符号如下
```text
// func (User) GetName() string
TEXT ·User·GetName(SB), NOSPLIT, $0
    // ...
```
如果是指针类型的接收器，函数符号位`·(*User)·GetName(SB)`，因为在Go汇编中，星号和小括号都无法作为函数名字，也就是**无法用汇编实现接收指针类型的方法**。


### 闭包函数

闭包函数的实现原理是编译器隐式构造了一个结构体，并在其中保存了函数指针和引用的变量
```go
type xxxClosure struct {
	fn uintptr
	x, y int
	name string
}
```
在函数符号上闭包函数会有一个`NEEDCTXT`的标志，表示在执行时需要一个上下文环境。AMD64环境下通过寄存器`DX`来传递这个上下文指针。一般闭包函数遵循以下流程
 * 构造闭包对象，其中保存外层变量的**引用**
 * 调用闭包函数时首先拿到闭包对象，用闭包对象初始化`DX`，然后从闭包对象中取出函数地址并通过CALL调用
```text
TEXT ·asmClosureBody(SB), NOSPLIT|NEEDCTXT, $0
    MOVQ 8(DX), AX // AX = ctx.x
    // ...
    MOVQ AX, 8(DX) // ctx.x = AX
    RET
```
