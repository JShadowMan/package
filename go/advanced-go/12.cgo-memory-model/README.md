CGO编程 - CGO内存模型
-------------------

如果在CGO处理的跨语言函数调用时涉及了指针的传递，则可能会出现Go语言和C语言共享某一段内存的场景。在Go语言函数栈的动态伸缩时可能导致栈中内存地址的移动（C语言的内存分配之后是不会发生变化的，这是两者内存模型最大的差异）。如果C语言持有的是移动之前的Go指针，那么以旧指针访问Go对象时会导致程序崩溃（非法地址访问，或者数据无法使用）。


### Go访问C内存

因为C语言申请内存之后只要不人为释放，那么在Go语言空间就可以放下大胆地使用。

>
> 借助CGO技术，我们可以在C语言环境创建大于2GB的内存，然后转为Go语言的切片使用。
> 这就突破Go语言中无法创建大于2GB内存的切片（参考runtime.makeslice函数的实现）的限制。
>


### C临时访问传入的Go内存

CGO之所以存在的一大原因是为了方便在Go语言中接纳吸收过去几十年来使用C/C++语言构建的大量的软件资源。

因为Go语言函数栈是可以动态伸缩的（将会导致变量的地址发生改变），所以在C语言中使用Go的内存可能会出现非法访问的问题。当然这里可以将Go语言内存先复制到C语言内存中来解决
```go
func printString(s string) {
	cs := C.CString(s)
	defer C.free(unsafe.Pointer(cs))
	
	C.doSomething(cs)
}
```
这种处理思路虽然是安全的，但是效率极其低下（因为需要多次分配内存并复制），过程也非常繁琐。

为了简化并高效处理此类问题，__CGO定义了专门的规则：在CGO调用的C语言函数返回前，CGO保证传入的Go语言内存在此期间不会发生移动，C语言函数可以大胆地使用Go语言的内存。__

在C语言需要长时间运行时，将会导致被C语言引用的G语言内存在C函数返回前不能被移动，从而可能间接地导致这个Go内存栈对应的goroutine不能动态伸缩内存被**阻塞**。

需要注意的是，在获取Go内存后需要马上传入C语言函数，不能保存到临时变量后再间接传入C语言函数。因为CGO只能保证在C函数调用之后被传入的Go语言内存不会发生移动，它并不能保证在传入C函数之前内存不发生变化。
```go
func wrong() {
	ptr := uintptr(unsafe.Pointer(&v))
	// do something
	C.assignValue(ptr)
}
```


### C长期持有Go指针对象

__不能在C语言函数中直接使用Go语言对象的内存__

*那在C语言中为什么有_GoString_类型的变量？*


### 导出C函数不能回Go内存

在Go语言中，Go是从一个固定的虚拟地址空间分配内存，而C语言分配的内存则不能使用Go语言保留的虚拟内存空间。在CGO环境，Go语言运行时默认会检查导出函数返回的内存是否有由Go语言分配的。如果有将抛出运行时异常。

该运行时异常由`_cgo_tsan_acquire()`函数进行检查，该方法是从LLVM项目移植过来的内存指针扫描函数，它会检查CGO函数返回的结果是否包含Go指针。

__可以通过设置环境变量GODEBUG=cgocheck=0来关闭指针检查行为，默认为1（对应一个简化版本的检测），如果需要完整的检测功能可以将gocheck设置为2__
