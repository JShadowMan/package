面向并发的内存模型
--------------

顺序编程语言中的顺序：所有指令都是以串行的方式执行，在相同的时刻有且仅有一个CPU
在顺序执行程序的指令。

并发编程的常见模型：多线程、消息传递
 * 主流操作系统都提供了系统级的多线程支持。
 * Erlang语言是基于消息传递并发编程模型的代表者（并发体之间不共享内存）
 * Go语言是基于消息并发模型的集大成者，它将基于CSP的并发模型内置到语言中（并发体共享内存）

Go语言中的并发体：Goroutine（是一种轻量级的线程，由go关键字启动）
 * Goroutine和系统线程不是等价的（尽管只有一个量的区别）

系统级线程：
 * 每个系统级线程会有一个固定的栈（一般默认是2M），主要是用来保存函数递归调用时的参数和局部变量
 * 固定栈带来了2个问题：一是对于很多只需要很小栈空间的线程是一个巨大的浪费；二是对少数需要巨大
 栈空间的线程又面临溢出的风险

Goroutine：
 * 一个Goroutine会以一个很小的栈启动（2K或者4K），当遇到深度递归导致栈空间不足时，Goroutine
 会根据需要动态伸缩栈大小（最大可达1G）

Go的运行时还包含了自己的调度器，调度器可以在n个系统线程上调度m个Goroutine。调度器的工作原理和
内核的调度是相似的，但是这个调度器只关注单独的Go程序中的Goroutine。

调度器采用的是半抢占式的协作调度，__只有在当前Goroutine发生阻塞时才会导致调度__。同时在用户
态，调度器会根据具体函数只保存必要的寄存器（系统级线程切换需要保存所有通用寄存器和标志寄存器），
切换的代价要比系统线程低得多。

原子操作：在并发编程中“最小的且不可并行化”的操作。

一般情况下，原子操作都是通过“互斥”访问来保证的，通常由特殊的CPU指令提供保护（cmpxchg？）。

原子操作配合互斥锁可以实现非常高效的单例模式【双重检测】。
