面向并发的内存模型
--------------

顺序编程语言中的顺序：所有指令都是以串行的方式执行，在相同的时刻有且仅有一个CPU
在顺序执行程序的指令。

并发编程的常见模型：多线程、消息传递
 * 主流操作系统都提供了系统级的多线程支持。
 * Erlang语言是基于消息传递并发编程模型的代表者（并发体之间不共享内存）
 * Go语言是基于消息并发模型的集大成者，它将基于CSP的并发模型内置到语言中（并发体共享内存）

Go语言中的并发体：Goroutine（是一种轻量级的线程，由go关键字启动）
 * Goroutine和系统线程不是等价的（尽管只有一个量的区别）

系统级线程：
 * 每个系统级线程会有一个固定的栈（一般默认是2M），主要是用来保存函数递归调用时的参数和局部变量
 * 固定栈带来了2个问题：一是对于很多只需要很小栈空间的线程是一个巨大的浪费；二是对少数需要巨大
 栈空间的线程又面临溢出的风险

Goroutine：
 * 一个Goroutine会以一个很小的栈启动（2K或者4K），当遇到深度递归导致栈空间不足时，Goroutine
 会根据需要动态伸缩栈大小（最大可达1G）

Go的运行时还包含了自己的调度器，调度器可以在n个系统线程上调度m个Goroutine。调度器的工作原理和
内核的调度是相似的，但是这个调度器只关注单独的Go程序中的Goroutine。

调度器采用的是半抢占式的协作调度，__只有在当前Goroutine发生阻塞时才会导致调度__。同时在用户
态，调度器会根据具体函数只保存必要的寄存器（系统级线程切换需要保存所有通用寄存器和标志寄存器），
切换的代价要比系统线程低得多。

原子操作：在并发编程中“最小的且不可并行化”的操作。

一般情况下，原子操作都是通过“互斥”访问来保证的，通常由特殊的CPU指令提供保护（cmpxchg？）。

原子操作配合互斥锁可以实现非常高效的单例模式【双重检测】。

`sync.atomic`包对基本数值类型及复杂对象的读写都提供了原子操作的支持。


### 顺序一致性内存模型

在Go语言中，同一个Goroutine线程内部，顺序一致性的内存模型是得到保证的。但是不同Goroutine之间，
并不能满足顺序一致性的内存模型。


### 初始化顺序

Go程序的初始化和执行总是从`main.main()`函数开始的。如果main包导入了其他的包，则会按照顺序将他们包含到
main包里（导入顺序依赖具体实现）。

在`main.main()`函数执行之前所有的代码（const, var, init()）都是运行在同一个Goroutine中，也就是程序
的主系统线程中（如果在初始化过程中使用go关键字启动了新的Goroutine，则会与`main()`并发执行）。


### Goroutine的创建

go语句会在当前Goroutine对应函数**返回前**创建新的Goroutine。


### 基于通道的通信

通道（channel）是在Goroutine之间进行同步的主要方法。

无缓存通道上的发送操作总在对应的接收操作完成前发生。
对于从无缓存通道进行的接收，发生在对该通道进行的发送完成之前。
对于带缓存的通道，对于通道中的第K个接收完成操作发生在第K+C个发送操作完成之前（C是管道的缓存大小）。

若在关闭通道后继续从中接收数据，接收者就会收到该通道返回的零值。


### 并发的同步控制

严谨的并发程序的正确性不应该依赖于CPU的执行速度和休眠时间等不靠谱因素的。

解决同步问题的思路是相同的：使用显式的同步。


### 常见的并发模式

并发不是并行。并发更关注的是程序的设计层面，并发的程序完全是可以顺序执行的。而并行更关注的是程序的运行层面，
并行一般是简单的大量重复。


### 并发的安全退出

Go语言并没有提供一个直接终止Goroutine的方法，因为这样会导致Goroutine之间的共享变量处在未定义的状态上。

当有多个通道均可操作时，select会随机选择一个通道。（基于此可以用select实现一个随机数生成器）


### 错误和异常

错误处理时每个编程语言都要考虑的一个重要话题。

在碰到异常时，我们还可以进一步地通过类型查询或类型断言来获取底层真实的错误类型，这样就可以获取更详细的错误信息。

在Go语言中，错误被认为是一种可以预期的结果，而异常则是一种非预期的结果，发生异常可能表示程序中存在bug或发生了其他不可控的问题。

Go语言库的实现习惯：即时在包内部使用了panic，在导出函数时也会被转化为明确的错误值。


#### 获取错误的上下文

有时我们为了方便上层用户理解，底层实现会将底层的错误重新包装为新的错误类型返回给上层用户。
上层用户在遇到错误时，上层用户获得性的错误类型，但是同时也丢失了底层最原始的错误类型。


### 剖析异常

对`recover()`的调用有着非常严格的要求：我们必须在`defer()`函数中**直接**调用`recover()`。

换句话说：`recover()`函数必须要和有异常的栈帧只隔一个栈帧才能正常捕获异常。





