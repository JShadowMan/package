面向并发的内存模型
--------------

顺序编程语言中的顺序：所有指令都是以串行的方式执行，在相同的时刻有且仅有一个CPU
在顺序执行程序的指令。

并发编程的常见模型：多线程、消息传递
 * 主流操作系统都提供了系统级的多线程支持。
 * Erlang语言是基于消息传递并发编程模型的代表者（并发体之间不共享内存）
 * Go语言是基于消息并发模型的集大成者，它将基于CSP的并发模型内置到语言中（并发体共享内存）

Go语言中的并发体：Goroutine（是一种轻量级的线程，由go关键字启动）
 * Goroutine和系统线程不是等价的（尽管只有一个量的区别）

系统级线程：
 * 每个系统级线程会有一个固定的栈（一般默认是2M），主要是用来保存函数递归调用时的参数和局部变量
 * 固定栈带来了2个问题：一是对于很多只需要很小栈空间的线程是一个巨大的浪费；二是对少数需要巨大
 栈空间的线程又面临溢出的风险

Goroutine：
 * 一个Goroutine会以一个很小的栈启动（2K或者4K），当遇到深度递归导致栈空间不足时，Goroutine
 会根据需要动态伸缩栈大小（最大可达1G）

Go的运行时还包含了自己的调度器，调度器可以在n个系统线程上调度m个Goroutine。调度器的工作原理和
内核的调度是相似的，但是这个调度器只关注单独的Go程序中的Goroutine。

调度器采用的是半抢占式的协作调度，__只有在当前Goroutine发生阻塞时才会导致调度__。同时在用户
态，调度器会根据具体函数只保存必要的寄存器（系统级线程切换需要保存所有通用寄存器和标志寄存器），
切换的代价要比系统线程低得多。

原子操作：在并发编程中“最小的且不可并行化”的操作。

一般情况下，原子操作都是通过“互斥”访问来保证的，通常由特殊的CPU指令提供保护（cmpxchg？）。

原子操作配合互斥锁可以实现非常高效的单例模式【双重检测】。

`sync.atomic`包对基本数值类型及复杂对象的读写都提供了原子操作的支持。


### 顺序一致性内存模型

在Go语言中，同一个Goroutine线程内部，顺序一致性的内存模型是得到保证的。但是不同Goroutine之间，
并不能满足顺序一致性的内存模型。


### 初始化顺序

Go程序的初始化和执行总是从`main.main()`函数开始的。如果main包导入了其他的包，则会按照顺序将他们包含到
main包里（导入顺序依赖具体实现）。

在`main.main()`函数执行之前所有的代码（const, var, init()）都是运行在同一个Goroutine中，也就是程序
的主系统线程中（如果在初始化过程中使用go关键字启动了新的Goroutine，则会与`main()`并发执行）。


### Goroutine的创建

go语句会在当前Goroutine对应函数**返回前**创建新的Goroutine。


### 基于通道的通信

通道（channel）是在Goroutine之间进行同步的主要方法。

无缓存通道上的发送操作总在对应的接收操作完成前发生。
对于从无缓存通道进行的接收，发生在对该通道进行的发送完成之前。
对于带缓存的通道，对于通道中的第K个接收完成操作发生在第K+C个发送操作完成之前（C是管道的缓存大小）。

若在关闭通道后继续从中接收数据，接收者就会收到该通道返回的零值。


### 并发的同步控制

严谨的并发程序的正确性不应该依赖于CPU的执行速度和休眠时间等不靠谱因素的。

解决同步问题的思路是相同的：使用显式的同步。


### 常见的并发模式

并发不是并行。并发更关注的是程序的设计层面，并发的程序完全是可以顺序执行的。而并行更关注的是程序的运行层面，
并行一般是简单的大量重复。





