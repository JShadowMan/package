背景
---
C++在类中有几个比较特殊的成员函数，如默认构造函数，析构函数等。如果程序员没有显式的定义一个特殊成员函数，在程序需要用到这些特殊成员函数时，编译器会隐式的为这个类生成一个默认的成员特殊函数。
> **这个默认生成的特殊成员函数会获得更高的代码执行效率**

如下示例
```c++
class T {
    private:  
        int apple;
};
```
当我们执行以下操作时，因为没有定义构造函数，而`t`定义时又需要构造函数，所以编译器会隐式的生成一个默认构造函数。这个默认生成的构造函数没有参数，并且包含空的函数体`T::T(){}`，所以虽然没定义构造函数，但是还是可以编译通过
```c++
T t;
```

如果为类显示的定义了非默认构造函数，如下
```c++
class T {
    private:
        int apple;
    public:
        T(int banana) { apple = banana; }
}
```

这时我们再执行以下操作，因为我们已经定义了一个非默认构造函数，所以编译器不会自动的为我们生成默认的构造函数，所以如下示例编译器会报错。
```c++
T t; // error, default constructor T::T() doesn't exist
```
如果我们显式的定义一个默认构造函数，那么原本由编译器完成的工作转移到我们程序员身上了。这无疑增大了程序员的工作，而且**我们显式定义的默认构造函数的代码执行效率没有编译器生成的默认构造函数代码执行效率高**
```c++
class T {
    private:
        int apple;
    public:
        T(){}
        T(int banana) { apple = banana; }
}
```

Defaulted functions
---
基于以上几点原因，C++11标准引入了一个新特性，即`defaulted函数`。只要在显式定义的默认构造函数后面加上`=default`就可以了，如下
```c++
class T {
    private:
        int apple;
    public:
        T() = default; // 默认构造函数
        T(int banana) { apple = banana; }
}
```
这样编译器就会自动生成默认构造函数`T::T(){}`，从而获得更高的代码执行效率。

Note
---
`defaulted函数`只能应用于类的特殊成员函数，且函数没有实参（包括默认实参），没有函数体。