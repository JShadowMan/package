打开一个Bolt数据库发生了什么？
------------------------

故事要从`bolt.Open`方法的调用开始说起，话说这个方法有3个参数，第一个是数据库文件的路径，
第二个是数据库文件的权限，第三个参数是表示如何打开一个数据库（参数）。函数签名如下
```go
func Open(path string, mode os.FileMode, options *Options) (*DB, error) {}
```

当传入空参数时，将会使用默认参数打开或者创建数据库文件。


### 打开数据库文件的总体流程

首先我们来看下整体的流程，然后再详细讲讲其中比较有意思的步骤。
 * 检查参数并复制部分值到DB结构体中
 * 打开或者创建（当文件不存在时）文件（根据参数中的是否只读决定以只读/读写方式打开）
    * 如果打开（或创建）文件失败，则执行关闭数据操作并返回错误
 * 创建文件锁，当两个进程同时对一个数据库进行读写操作时可能会导致元数据损坏。
    * 在Windows下将会创建.lock文件来表示文件锁，因为进程无法在同一个进程下共享排它锁
 * 获取数据库的文件信息，并根据文件大小走不同的逻辑
    * 如果文件大小为0，则执行数据库初始化
        * 获取系统内存的页大小，并根据这个值创建4个页大小的buffer
        * 首先创建2个meta页（页面id为0和1），其中保存数据库的元数据
        * 接着创建freelist页（页面id为2），其中保存所有可用的页面id列表
        * 最后创建leaf页，其中保存的数据将会在之后介绍
        * 最后将这个buffer刷写到文件中
    * 如果文件大小不为0，则读取前4k字节并验证元数据页是否正确（魔数，版本以及校验和）
        * 如果校验不通过则尝试修改数据库的页面大小，并继续
 * 为数据库文件创建内存映射
    * 创建内存映射失败则关闭数据库并返回错误
 * 读取并保存相应的空闲页面id

可以看到整体的步骤还是比较简单明了的，我们就挑其中一些步骤深入了解下。


### 创建文件锁

在打开文件之后，就会根据是否只读创建排它锁（非只读）或者共享锁（只读）。这里是一个不同系统下
实现不一样的地方。在Go中可以使用__构建约束__来实现选择性编译。一般位于最头部的注释行上。
```go
// +build unix

// 构建标记位于每个文件的最前面，不能有任何包括package的声明
package main
```
具体可参考Go文档中关于build的解释[传送门][1]

关于文件锁的实现，这里就使用了这个特性，区分了在windows和unix下的不同实现。这里的主要不同
一个是所调用的API是依赖系统实现的，第二则是实现方式的不同。在windows下是通过创建.lock文件
并在该文件上上锁实现的，而unix则是直接在数据库文件的描述符上上锁实现。
```go
// bolt_windows.go
func flock(db *DB, mode os.FileMode, exclusive bool, timeout time.Duration) error {
	f, _ := os.OpenFile(db.path+lockExt, os.O_CREATE, mode)
	// ...
	_ := lockFileEx(syscall.Handle(f.Fd()), flag, 0, 1, 0, &syscall.Overlapped{})
	// ...
}

// bolt_unix.go
func flock(db *DB, mode os.FileMode, exclusive bool, timeout time.Duration) error {
	// ...
	_ := syscall.Flock(int(db.file.Fd()), flag|syscall.LOCK_NB)
	// ...
}
```

至于windows为何不在数据库文件上直接加锁处理，从注释给出的理由是：__无法在相同进程中共享排它锁。__
具体是个啥情况我们在后续章节里再填坑。

做这件事的目的也很简单，就是为了防止两个进程同时打开这个文件然后同时写入导致数据冲突问题。但是注意
在只读情况下同时打开是OK的。


### 初始化数据库到底初始化了什么？

简单来说，就是创建了2个meta页，1个freelist页，一个leaf页。每个页的长度与系统内存页的长度一致。
这主要是为了与内存页面进行对齐，这有助于高效利用CPU缓存和内存读取周期。

这边程序利用了一个小技巧，就是如果把一个结构体存入到一个字节数组中。这里是利用`unsafe`包中的指针
操作来做到这个事情。需要了解的背景是一个指针指向的是某一块内存的起始位置，具体这块内存表示的是什么
东西（数组，或者结构体）是看程序怎么利用和解释的。我们来看一个例子
```go
package main

import (
	"fmt"
	"unsafe"
)

type Node struct{
	Id uint16
	Count uint32
}

func main() {
	v := make([]byte, 6)
	n := (*Node)(unsafe.Pointer(&v[0]))

	n.Id = 1
	n.Count = 0x0304

	fmt.Println(v) // [1 0 0 0 4 3]
}
```

从这里可以看到我们Node结构体中的数据将会保存在字节数组中（小端形式）。

在数据库初始化过程会首先创建2个meta页面，其中保存着关于数据库的相关配置信息（如魔数，版本，校验和）
等。在初始化时两个meta页面除了页面id，其余内容都是一致的。

我们首先看下page类型的页面结构
```plain
// page.go
+--------+--------+--------+----------+-----+
|   Id   | Flags  | Count  | Overflow | Ptr |
+--------+--------+--------+----------+-----+
| uint64 | uint16 | uint16 | uint32   | *   |
+--------+--------+--------+----------+-----+
```

Id就是每个页面的Id，为64位无符号整数，假如每个页面有4k，则最大可以保存4k * (2 ^ 64 - 1) = 


 [1]: https://golang.org/pkg/go/build/
